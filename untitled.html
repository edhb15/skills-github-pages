<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Poly Track 3D Racer</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/all.min.css"></link>
  <style>
    body, html { margin: 0; overflow: hidden; height: 100%; }
    canvas { display: block; }
    #recordDisplay { position: absolute; top: 10px; left: 10px; color: white; font-size: 18px; }
    #winnerDisplay { position: absolute; top: 50px; left: 10px; color: yellow; font-size: 24px; }
    #speedometer { position: absolute; bottom: 10px; right: 10px; color: white; font-size: 18px; }
    #controlsModal { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.8); justify-content: center; align-items: center; }
    #controlsModalContent { background: white; padding: 20px; border-radius: 8px; text-align: center; }
  </style>
</head>
<body class="bg-gray-900">
  <div id="intro" class="absolute top-0 left-0 w-full h-full flex flex-col items-center justify-center">
    <h1 class="text-4xl text-white font-bold mb-4">Poly Track 3D Racer</h1>
    <p class="text-lg text-gray-300 mb-8">Race through the poly track and set your best time!</p>
    <div class="flex space-x-4">
      <button id="startGameBtn" class="bg-green-500 text-white px-4 py-2 rounded hover:bg-green-600">Start Game</button>
      <button id="resetGameBtn" class="bg-red-500 text-white px-4 py-2 rounded hover:bg-red-600">Reset Game</button>
      <button id="controlsBtn" class="bg-blue-500 text-white px-4 py-2 rounded hover:bg-blue-600">Controls</button>
    </div>
  </div>

  <div id="controlsModal" class="flex">
    <div id="controlsModalContent">
      <h2 class="text-2xl font-bold mb-4">Game Controls</h2>
      <p class="mb-2"><strong>W:</strong> Move Forward</p>
      <p class="mb-2"><strong>A:</strong> Turn Left</p>
      <p class="mb-2"><strong>D:</strong> Turn Right</p>
      <button id="closeControlsBtn" class="mt-4 bg-red-500 text-white px-4 py-2 rounded hover:bg-red-600">Close</button>
    </div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    // Set up scene, camera, and renderer
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer();
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // Game Variables
    let car;
    let carSpeed = 0;
    let maxSpeed = 0.5; // Increased max speed
    let carRotationSpeed = 0.05;
    let carAcceleration = 0.05; // Increased acceleration
    let carFriction = 0.98; // Slightly reduced friction
    let finishLinePassed = false;
    let raceStartTime = null;
    let bestTime = null;
    let lapCount = 0;
    let gameOver = false;
    let currentLevel = 1;

    // Control states for the player
    let moveForward = false;
    let turnLeft = false;
    let turnRight = false;

    // Track Setup
    const trackRadius = 10;
    const trackLength = 500;  // Make the track longer
    const obstacles = [];
    const speedBoostZones = [];

    // Create track
    function createTrack() {
      const geometry = new THREE.CylinderGeometry(trackRadius, trackRadius, 1, 50);
      const material = new THREE.MeshBasicMaterial({ color: 0xaaaaaa });
      const trackMesh = new THREE.Mesh(geometry, material);
      trackMesh.rotation.x = Math.PI / 2;
      trackMesh.position.set(0, 0, -trackLength / 2);
      scene.add(trackMesh);

      // Create walls along the track
      const wallGeometry = new THREE.BoxGeometry(0.5, 2, trackLength);
      const wallMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
      const leftWall = new THREE.Mesh(wallGeometry, wallMaterial);
      leftWall.position.set(-trackRadius - 0.25, 1, 0);
      scene.add(leftWall);
      const rightWall = new THREE.Mesh(wallGeometry, wallMaterial);
      rightWall.position.set(trackRadius + 0.25, 1, 0);
      scene.add(rightWall);

      // Create finish line (goal) at the far end of the track
      const finishLine = new THREE.BoxGeometry(5, 0.1, 50);  // Increased size for visibility
      const finishMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00 });  // Bright green
      const finishLineMesh = new THREE.Mesh(finishLine, finishMaterial);
      finishLineMesh.position.set(0, 0.1, trackLength / 2);  // Position at the end of the track
      scene.add(finishLineMesh);

      // Create speed boost zones
      createSpeedBoostZone(0, 100);
      createSpeedBoostZone(0, 300);

      // Create obstacles **ensured to be within track bounds**
      for (let i = 0; i < 10 * currentLevel; i++) {
        createObstacle();
      }
    }

    // Create speed boost zone
    function createSpeedBoostZone(x, z) {
      const geometry = new THREE.BoxGeometry(2, 0.1, 2);
      const material = new THREE.MeshBasicMaterial({ color: 0x0000ff });
      const boostZone = new THREE.Mesh(geometry, material);
      boostZone.position.set(x, 0.1, z);
      scene.add(boostZone);
      speedBoostZones.push(boostZone);
    }

    // Create obstacles with boundaries
    function createObstacle() {
      const x = (Math.random() - 0.5) * trackRadius * 2;
      const z = (Math.random() - 0.5) * trackLength;

      const geometry = new THREE.BoxGeometry(2, 2, 2);
      const material = new THREE.MeshBasicMaterial({ color: 0xff6600 });
      const obstacle = new THREE.Mesh(geometry, material);
      obstacle.position.set(x, 1, z);
      scene.add(obstacle);
      obstacles.push(obstacle);
    }

    // Create car
    function createCar(color, startPosX, startPosZ) {
      const carGeometry = new THREE.BoxGeometry(1, 0.5, 2);
      const carMaterial = new THREE.MeshBasicMaterial({ color: color });
      const car = new THREE.Mesh(carGeometry, carMaterial);
      car.position.set(startPosX, 0.25, startPosZ);
      scene.add(car);
      return car;
    }

    // Add basic light
    function addLights() {
      const ambientLight = new THREE.AmbientLight(0x404040);
      const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
      directionalLight.position.set(5, 5, 5).normalize();
      scene.add(ambientLight);
      scene.add(directionalLight);
    }

    // Handle car movement with friction
    function handleControls() {
      if (moveForward) {
        carSpeed = Math.min(carSpeed + carAcceleration, maxSpeed);
      } else {
        carSpeed = Math.max(carSpeed * carFriction, 0);
      }

      if (turnLeft) {
        car.rotation.y += carRotationSpeed;
      }

      if (turnRight) {
        car.rotation.y -= carRotationSpeed;
      }

      // Update car position based on its rotation and speed
      car.position.x += carSpeed * Math.sin(car.rotation.y);
      car.position.z += carSpeed * Math.cos(car.rotation.y);
    }

    // Event listener for key controls
    function handleKeyDown(event) {
      if (event.key === 'w') moveForward = true; // Move Forward
      if (event.key === 'a') turnLeft = true; // Turn Left
      if (event.key === 'd') turnRight = true; // Turn Right
    }

    function handleKeyUp(event) {
      if (event.key === 'w') moveForward = false; // Stop Moving Forward
      if (event.key === 'a') turnLeft = false; // Stop Turning Left
      if (event.key === 'd') turnRight = false; // Stop Turning Right
    }

    // Add event listeners for key down/up
    window.addEventListener('keydown', handleKeyDown);
    window.addEventListener('keyup', handleKeyUp);

    // Check collisions with obstacles
    function checkCollisions() {
      obstacles.forEach((obstacle) => {
        if (car.position.distanceTo(obstacle.position) < 2) {
          resetCar();
        }
      });

      speedBoostZones.forEach((zone) => {
        if (car.position.distanceTo(zone.position) < 3) {
          carSpeed = Math.min(carSpeed * 1.5, maxSpeed);
        }
      });

      // Check if car goes outside track boundaries
      if (Math.abs(car.position.x) > trackRadius) {
        resetCar();
      }
    }

    // Check finish line and update records
    function checkFinishLine() {
      if (!finishLinePassed && car.position.z > trackLength / 2) {
        finishLinePassed = true;
        raceStartTime = Date.now();
        lapCount++;
        nextLevel();
      }
    }

    // Update records
    function updateRecords() {
      if (finishLinePassed) {
        const raceTime = (Date.now() - raceStartTime) / 1000;
        if (!bestTime || raceTime < bestTime) {
          bestTime = raceTime;
        }
      }
    }

    // Display records
    function displayRecords() {
      const recordText = `Best Time: ${bestTime ? bestTime.toFixed(2) : 'N/A'}s | Laps: ${lapCount} | Level: ${currentLevel}`;
      document.getElementById('recordDisplay').innerText = recordText;
    }

    // Display speedometer
    function displaySpeedometer() {
      const speedKmh = (carSpeed / maxSpeed) * 200; // Convert to km/h
      const speedText = `Speed: ${speedKmh.toFixed(2)} km/h`;
      document.getElementById('speedometer').innerText = speedText;
    }

    // Reset car position and speed
    function resetCar() {
      car.position.set(0, 0.25, 0);
      carSpeed = 0;
    }

    // Move to the next level
    function nextLevel() {
      currentLevel++;
      finishLinePassed = false;
      resetCar();
      clearTrack();
      createTrack();
    }

    // Clear the track
    function clearTrack() {
      obstacles.forEach(obstacle => scene.remove(obstacle));
      speedBoostZones.forEach(zone => scene.remove(zone));
      obstacles.length = 0;
      speedBoostZones.length = 0;
    }

    // Initialize game
    function init() {
      createTrack();
      car = createCar(0x00ff00, 0, 0); // Starting position
      addLights();
      camera.position.z = 10;
      camera.position.y = 5;

      // Create record display
      const recordDisplay = document.createElement('div');
      recordDisplay.id = 'recordDisplay';
      document.body.appendChild(recordDisplay);

      const winnerDisplay = document.createElement('div');
      winnerDisplay.id = 'winnerDisplay';
      document.body.appendChild(winnerDisplay);

      // Create speedometer display
      const speedometer = document.createElement('div');
      speedometer.id = 'speedometer';
      document.body.appendChild(speedometer);

      animate();
    }

    // Animation loop
    function animate() {
      if (gameOver) return;

      requestAnimationFrame(animate);

      handleControls();
      checkCollisions();
      checkFinishLine();
      updateRecords();
      displaySpeedometer();

      // Camera follows the car
      camera.position.x = car.position.x;
      camera.position.z = car.position.z - 10;  // Adjust this for a better perspective
      camera.position.y = car.position.y + 5;  // Adjust camera height
      camera.lookAt(car.position);

      // Render the scene
      renderer.render(scene, camera);
      displayRecords();
    }

    // Start game button event listener
    document.getElementById('startGameBtn').addEventListener('click', () => {
      document.getElementById('intro').style.display = 'none';
      init();
    });

    // Reset game button event listener
    document.getElementById('resetGameBtn').addEventListener('click', () => {
      location.reload();
    });

    // Controls button event listener
    document.getElementById('controlsBtn').addEventListener('click', () => {
      document.getElementById('controlsModal').style.display = 'flex';
    });

    // Close controls modal event listener
    document.getElementById('closeControlsBtn').addEventListener('click', () => {
      document.getElementById('controlsModal').style.display = 'none';
    });
  </script>
</body>
</html>